## 题意

给定一个0-1串s，长度为n，下标从0开始，求一个位置k，满足0<=k<=n, 并且子串s[0..k - 1]中的0的个数与子串s[k..n - 1]中1的个数相等。 注意：
（1） 如果k = 0, s[0..k - 1]视为空串
（2） 如果k = n, s[k..n - 1]视为空串
（3） 如果存在多个k值，输处任何一个都可以
（4） 如果不存在这样的k值，请输出-1

## 样例输入

```cpp
01	//01串 {1->1000000}
```
## 样例输出

```cpp
1	//题目中的k值
```

## 思路

emmmm这题很妙，很考验思维，为什么直接输出串中一的个数就可以了呢？仔细想想，从前到后，如果一个位置是1的话，那么k位置后面就会少一个1，如果是0的话，k位置后面刚好会有一个1与之对应。很神奇吧。

## 总结

这题确实很妙啊，感觉可以出到周赛里面

## code

```cpp
const int N = 1000000;
char a[N];

int main(void)
{
    int ans = 0;
    while(scanf("%s", &a) != EOF){
        ans = 0;
        
        //output the sum of 1 in this string
        for(int i=0;i<strlen(a);i++){
            if(a[i] == '1'){
                ans++;
            }
        }
        printf("%d\n", ans);
    }
}
```