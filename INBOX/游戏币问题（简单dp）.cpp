/*问题概述: 在一个n*m的矩形方格里,每个网格里有一定数量的游戏币.我们可以控制机器人从左上角出发,到右下角
         结束,并且会拾取沿途经过的格子里的游戏币,请计算机器人最富能得到多少游戏币

  输入样例:                         对应输出:
			  3 4                               24
			  3 1 2 8 
			  5 3 4 6
			  1 0 2 3
*/

#include <stdio.h>
int main(void)
{
	int i, j;
	int m, n;
	int map[22][22] = {0};
	int dp[22][22] = {0};

    scanf("%d%d", &m, &n);
	for(i=1;i<=m;i++)                     /*将最外围的一圈全部设为0枚金币,这样就不用处理边界问题*/
	{
		for(j=1;j<=n;j++)
			scanf("%d", &map[i][j]);
	}

	for(i=1;i<=n-1;i++)         /*递推求解各个子问题，自问题即从相邻的两步跳过来，二者之一的更大值*/
	{
		for(j=1;j<=n;j++)
		{
			if(dp[i][j-1]>dp[i-1][j])//看看上面和左面的数值谁更大
				dp[i][j] = dp[i][j-1]+map[i][j];
			else
				dp[i][j] = dp[i-1][j]+map[i][j];
		}
	}
	printf("%d\n", dp[m][n]);
	return 0;
}
/*动态规划:
     通过把原问题分解为相对简单的子问题而定方式求解的方法
         流程:
                 找到最小子问题
				       ↓
	 找到递推关系式,并将每个子问题答案储在表中
	                   ↓
				求出原问题最优解                               */