/*
Description

刷了一天题的zy已经筋疲力尽，正在他准备上床时，才意识到自己所有科目的作业都没写，但这个时候再认真写
就已经晚了，于是他只好找同学抄，但其实班里也只有那么寥寥几个人写了作业，这就让zy非常头疼，因为平时分还是
非常重要的。
现已知有m门科目要交作业，班里只有n个人写了作业，问zy至少要找多少人借作业才能把所有作业全部搞定
PS:zy找同学借作业时会将那个同学的所有作业全部借来
Input

单实例测试，
第一行输入两个正整数n,m(n,m<=7)
接下来是一个n*m的01矩阵，第i行第j列为1表示第i个人做了第j门作业，为0表示没做，数据保证每个作业至少有一个人做了
Output

输出一个整数表示zy最少要找多少人


 */
/*
	这题可以暴力枚举每一种情况！
	首先分析每个人都有借和不借两种情况，这样m个人就是2^m种情况，因为m<=7，所以这种方法是可行的，
	那么如何实现呢？只要用一个数的二进制表示状态就好了，比如5的二进制是0000101，对应的状态是“只向第1个人和第3个人借"
	之后对每一种状态判断它是否能借到所有的作业，再判断下是不是比当前答案更优即可
*/
#include <stdio.h>
#include <string.h>

int a[11][11];//地图
int work[11];//??
int qk[9] = {0,1,2,4,8,16,32,64,128};//不同人数对应的总情况数

int main(void)
{
	int n, m;//行数，列数，人数，作业数。
	int i, j, k;//不用我解释了
	int temp;
	int ans;//答案
	int sum;

	scanf("%d%d", &n, &m);//输入行数列数，行数是人数！！艹。

	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
			scanf("%d", &a[i][j]);//读入作业数据，按每个人读入作业。
	}

	ans = n;//答案是人数

	for(i=0;i<=qk[n]-1;i++)//枚举每一种选人情况从一个都不选到选所有人
	{
		memset(work, 0, sizeof(work));//清理缓存
		temp = i;//情况编号。待会要转换成二进制。
		sum = 0;//人数和
		for(j=1;j<=n;j++)//枚举人，通过01值看看这个人选不选。
		{
			if(temp%2==1)//如果选
			{
				sum++;//人数++
				for(k=1;k<=m;k++)//吧作业状态移到work中
					work[k] += a[j][k];
			}
			temp /= 2;
		}
		for(j=1;j<=m;j++)//看看作业齐不齐
		{
			if(work[j]==0)
				break;
		}
		if(j==m+1 && sum<ans)//如果总人数更小，而且作业齐。
			ans = sum;
	}

	printf("%d\n", ans);//输出最优人数
	return 0;
}
